# 📂 01.15 수업 내용  
## 📍 안내사항

## ✅ (주제1)

### catch 상에서의 sout vs throw new
`catch` 블록 내에서 sout을 쓰는 것과 _다시 예외를 던지는(throw new)_ 것의 차이는,
내부에서 문제를 해결할 것인가 vs 상위 메서드에게 보고를 할 것인가 라고 비유할 수 있음.

1. System.out.println() - 예외처리 후 소멸
    - 여기서 문제 해결을 다 했고, 프로그램을 진행하라는 의미.
        1. 목적 : 사용자에게 에러를 안내하고, 프로그램이 비정상 종료되지 않게 처리하는 것.
        2. 특징 : catch문 이후에 추가적인 코드들이 정상적으로 실행됨 (현재 finally 이후 코드가 없기 때문에 확인하지 못했음)

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다.");   // 이거 띄워놓고
}
System.out.println("이 뒷부분이 계속 실행됩니다.");   // catch 바깥의 코드들이 실행됨.
```

2. `throw new` (예외 재발생 - 전파)
- 예외 처리 자체가 불가능하다, 혹은 해당 사실을 상위 메서드에 전달해줘야 한다는 의미.
    1. 목적 : 예외를 _다시_ 발생시켜 상위 메서드(호출한 곳)로 예외를 전달하는 것.
    2. 현재 메서드는 즉시 중단되며, 상위 메서드에서 다시 try - catch 로 잡아내거나, 또 throws로 던지는 형태

```java
try{
int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("아까처럼 기록하는 부분 : 0 으로 나누기가 콘솔에 찍힙니다.");
    throw new RuntimeException("심각한 오류 발생 - 상위 메서드에서 처리하기");
}
System.out.println("그러면 이부분이 실행이 되지 않음");
```

## ✅ Lambda Expression (람다식)
### 정의
Java 8 도입된 함수형 프로그래밍 스타일을 Java에 적용한 것으로 
_메서드를 하나의 식(expression)으로 표현한 것_ 을 의미함.
- 원래는 익명 함수(Anonymous Function)이라고 부름. 기존의 Java에서는 메서드 하나를 만들기 위해
반드시 클래스를 만들고 객체를 생성해야하지만(정적 메서드 제외), 람다식을 사용하면 해당 과정을 줄일 수 있음.

### 문법 구조
기존 메서드에서 메서드명과 return 타입을 제거하고 `->`를 사용합니다. (JS에서는 `=>` 사용)  
`(매개변수) -> {실행문}`

### 코드 예시
- 두 수 중 더 큰 숫자를 return하는 메서드를 정의
1. 기존 코드

```java
Comparator<Integer> comp = new Comparator<>() {
    @Override
    public int compare(Integer a, Integer b) {
        return a.compareTo(b);
    }
}
// 직접 정의
public class Temp {
    public int retrunMax(int a, int b) {
        int result = 0;
        if ( a > b ) {
            result = a;
        } else {
            result = b;
        }
        return result;
    }
}
```

2. Lambda Expression 적용
```java
Comparator<Integer> comp = (a, b) -> a.compareTo(b);
```

### 람다식을 사용하는 이유 (장점)
1. 코드 간결성
    - 불필요한 코드 반복이 사라짐. 클래스 정의 / 메서드 정의 등을 제외하고 
   표현식에 해당하는 부분만 작성할 수 있음.
2. 컬렉션 (Collection) 활용의 극대화
    - SpringBoot에서 Security 관련에서 자주 사용하겠지만 원래는 Collection과 관련된
   Stream API와 결합했을 때 큰 효과를 가짐.  
   배열이나 리스트의 데이터를 필터링하거나 변환할 때 `for / if`문을 줄일 수 있음.

List에서 짝수만 출력하는 예시
```java
List<Integer> nums = List.of(1,2,3,4,5,6,7,8,9,10);
List<Integer> evenNums = new ArrayList<>();
for (Integer num : nums) {
    if (num % 2 == 0) evenNums.add(num);
}
System.out.println(evenNums);
// 람다식 적용
nums.stream().filter(n -> n % 2 == 0).forEach(System.out::println);
```

3. 병렬 처리의 용이성
    - 람다식을 사용하면 개발자가 직접 스레드를 관리하지 않아도 Java 내에서 데이터를 나누어
   여러 CPU에서 동시에 처리(비동기적처리 혹은 병렬처리)하기 쉬운 구조가 됨.

### 함수형 인터페이스 (제한)
- 람다식 자체는 아무데나 쓸 수 있는 것은 아니고 _딱 하나의 추상 메서드만 가진 인터페이스_ 에서만 사용 가능.
이를 `함수형 인터페이스(@FunctionalInterface)`라고 함.

### 람다식 문법 생략 규칙
- 매개변수 타입 생략 : 인터페이스 내에 자료형이 정의 되어 있으므로 생략 가능  
`(int a) -> { ... }` -> `(a) -> { ... }`
- 매개변수가 하나라면 괄호 생략 가능  
`(a) -> { ... } ` -> `a -> { ...}`
- 실행문이 한 줄이면 `{ }`와 `return` 문구 생략 가능  
`a -> { retrun a * a; }` -> `a -> a * a;`

### 자주 사용되는 Stream API
1. filter
    - 데이터 중에서 특정 조건에 맞는 것만 골라내는 역할
    - 특징 : 결과 데이터의 개수가 줄어들 수 있지만, 데이터의 자료형은 변경 x
    - 코드 예시 : `s -> s >= 60` - 점수가 60 점 이상인 것만 통과됨.
2. map
    - 데이터를 다른 값이나 형태로 바꾸는 역할 (Frontend에서도 자주 쓰임)
    - 특징 : 데이터의 개수는 원본과 동일하지만, 데이터의 값이나 자료형이 변경될 수 있음.
    - 코드 예시 : `s -> s + 5` 각 scores의 내부 s에 대해 +5를 한 결과값이 도출됨.
3. sorted
    - 데이터를 특정 기준에 따라서 순서대로 나열하는 역할
    - 특징 : 데이터의 내용이나 개수는 변하지 않고 오직 순서만 바뀜.
    - 코드 예시 : `Comparator.reverseOrder()` 내림 차순 정렬에 해당.
적용 사례
```java
List<Integer> scores = List.of(23, 1654, 67, 147, 11, 5, 4, 98, 66, 53);
scores.stream()                        // 1. StreamAPI 사용
    .filter(s -> s >= 60)              // 2. 60점 미만 제외
    .map(s -> s + 5)                   // 3. 남아있는 것들에 5점씩 더함
    .sorted()                          // 4. 오름 차순으로 정렬
    .forEach(System.out::println);     // 5. 각각 출력
```

# 🚨발생한 문제


# 📖 복습 & 확인
✔️ 내용
💡📌📍🚩🚨⚠️